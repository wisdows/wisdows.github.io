<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="WisdowsBlog,如果人生有遗憾，那就是没有早点遇到你~">
  <meta name="author" content="Wisdows">
  <meta name="keywords" content="Wisdows, 饶弟, WisdowsBlog, 王者★孤傲">
  <title>Redis持久化存储实现以及原理讲解 WisdowsBlog WisdowsBlog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<link rel="alternate" href="/atom.xml" title="WisdowsBlog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>WisdowsBlog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/16.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期日, 八月 18日 2019, 5:19 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.9k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      14 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <blockquote>
<p>为什么要做持久化存储?</p>
</blockquote>
<p>持久化存储是将 Redis 存储在内存中的数据存储在硬盘中，实现数据的永久保存。我们都知道 Redis 是一个基于内存的 nosql 数据库，内存存储很容易造成数据的丢失，因为当服务器关机等一些异常情况都会导致存储在内存中的数据丢失。</p>
<blockquote>
<p>持久化存储分类</p>
</blockquote>
<p>在 Redis 中，持久化存储分为两种。一种是 aof 日志追加的方式，另外一种是 rdb 数据快照的方式。</p>
<blockquote>
<p>RDB 持久化存储</p>
</blockquote>
<pre><code>什么是RDB持久化存储</code></pre><p>RDB 持久化存储即是将 redis 存在内存中的数据以快照的形式保存在本地磁盘中。</p>
<pre><code>.RDB持久化存储分为自动备份和手动备份</code></pre><p>1.手动备份通过 save 命令和 bgsave 命令。save 是同步阻塞，而 bgsave 是非阻塞(阻塞实际发生在 fork 的子进程中)。因此，在我们实际过程中大多是使用 bgsave 命令实现备份.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SAVE</span></span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> BGSAVE</span></span><br><span class="line">Background saving started</span><br></pre></td></tr></tbody></table></figure>

<p>2.自动备份<br>a.修改配置项 save m n 即表示在 m 秒内执行了 n 次命令则进行备份.<br>b.当 Redis 从服务器项主服务器发送复制请求时，主服务器则会使用 bgsave 命令生成 rbd 文件，然后传输给从服务器.<br>c.当执行 debug reload 命令时也会使用 save 命令生成 rdb 文件.<br>d.当使用 shutdown 命令关掉服务时，如果没有启用 aof 方式实现持久化则会采用 bgsave 的方式做持久化.同时 shutdown 后面可以加备份参数[nosave|save].</p>
<pre><code>bgsave持久化存储实现原理</code></pre><p><img src="http://qiniucloud.qqdeveloper.com/mweb/14.png" srcset="undefined" alt="14"></p>
<p>1.执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如果存在则直接返回. 2.父进程 fork 一个子进程(fork 的过程中会造成阻塞的情况),这个过程可以使用 info stats 命令查看 latest<em>fork_usec 选项,查看最近一次 fork 操作小号的时间,单位是微妙. 3.父进程 fork 完之后,则会返回 Background saving started 信息提示,此时 fork 阻塞解除.<br>4.fork 出的子进程开始根据父进程内存数据生成临时的快照文件，然后替换原文件.使用 lastsave 命令可以查看最后一次生成 rdb 的时间，对应 info 的 rdb_last_save_time 选项. 5.当备份完毕之后向父进程发送完成信息，具体可以见 info Persistence 下的 rbd</em>*选项.</p>
<pre><code>RDB持久化的优势与劣势</code></pre><p>优势: 1.文件实现的数据快照，全量备份，便于数据的传输.比如我们需要把 A 服务器上的备份文件传输到 B 服务器上面，直接将 rdb 文件拷贝即可. 2.文件采用压缩的二进制文件，当重启服务时加载数据文件，比 aof 方式更快.<br>劣势:<br>1.rbd 采用加密的二进制格式存储文件，由于 Redis 各个版本之间的兼容性问题也导致 rdb 由版本兼容问题导致无法再其他的 Redis 版本中使用. 2.时效性差，容易造成数据的不完整性.因为 rdb 并不是实时备份，当某个时间段 Redis 服务出现异常，内存数据丢失，这段时间的数据是无法恢复的，因此易导致数据的丢失.<br>RDB 文件常见的处理方式 1.当遇到磁盘写满情况，可以使用如下命令来切换存储磁盘</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// dirName则是新的存储目录名(该方式同样适用于aof格式)</span><br><span class="line">config set dir dirName</span><br></pre></td></tr></tbody></table></figure>

<p>2.文件压缩处理，虽然对 CPU 具有消耗，但是减少体积的暂用，同时做文件传输(主从复制)也减少消耗.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 修改压缩开启或关闭</span><br><span class="line">config set rdbcompression yes|no</span><br></pre></td></tr></tbody></table></figure>

<p>3.rbd 备份文件损坏检测.可以使用 redis-check-rdb 工具检测 rdb 文件,该工具默认在/usr/local/bin/目录下面.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@syncd redis-data]# /usr/local/bin/redis-check-rdb ./6379-rdb.rdb</span><br><span class="line">[offset 0] Checking RDB file ./6379-rdb.rdb</span><br><span class="line">[offset 26] AUX FIELD redis-ver = '5.0.3'</span><br><span class="line">[offset 40] AUX FIELD redis-bits = '64'</span><br><span class="line">[offset 52] AUX FIELD ctime = '1552061947'</span><br><span class="line">[offset 67] AUX FIELD used-mem = '852984'</span><br><span class="line">[offset 83] AUX FIELD aof-preamble = '0'</span><br><span class="line">[offset 85] Selecting DB ID 0</span><br><span class="line">[offset 105] Checksum OK</span><br><span class="line">[offset 105] \o/ RDB looks OK! \o/</span><br><span class="line">[info] 1 keys read</span><br><span class="line">[info] 0 expires</span><br><span class="line">[info] 0 already expired</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>AOF 持久化存储</p>
</blockquote>
<pre><code>AOF持久化存储是什么</code></pre><p>AOF 持久化存储便是以日志的形式将 redis 存储在 aof_buf 缓冲区中的数据写入到磁盘中。简而言之，就是记录 redis 的操作日志，将 redis 执行过的命令记录下载，当我们需要数据恢复时，redis 去重新执行一次日志文件中的命令.</p>
<pre><code>如何配置持久化存储</code></pre><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将no改为yes，控制aof开启与否</span><br><span class="line">appendonly no</span><br><span class="line">// 控制aof文件名称，存储的目录便是dir配置项</span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line">// 三种备份策略(三者只需要开启以一个即可)</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always // 命令写入立即写入磁盘</span></span><br><span class="line">appendfsync everysec // 每秒实现文件的同步，写入磁盘</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no // 随机进行文件的同步,同步操作则交给操作系统来负责，通常时间是最长30s</span></span><br></pre></td></tr></tbody></table></figure>

<pre><code>AOF持久化存储实现原理</code></pre><p>aof 日志追加方式实现持久化存储，需要经历如下四个过程.命令写入-&gt;文件同步-&gt;文件重写-&gt;文件重载<br><img src="http://qiniucloud.qqdeveloper.com/mweb/15.png" srcset="undefined" alt="15"><br>1.redis 命令写入，此时会将 redis 命令写入 aof_buf 换从区. 2.缓冲区中数据根据备份策略实现写入日志文件. 3.当 aof 的文件越来越庞大，会根据我们的配置策略来实现 aof 的重写，实现文件的压缩，减少体积. 4.当 redis 重新启动时，在去重写加载 aof 文件，达到数据恢复的目的.</p>
<pre><code>命令写入</code></pre><p>命令写入主要是将文件执行过的命令写入到日志文件中.并且日志文件尊徐文本协议格式，下面示例代码便是 aof 日志文件中存储的内容格式.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span><br></pre></td></tr></tbody></table></figure>

<p>aof 采用的是文本协议格式。主要是原因根据资料提示，可以能使由于如下原因. 1.文本协议的兼容性好.前面我们提及到了 rdb 文件是进行二进制加密，可能不同版本之间会出现不兼容的情况，采用文本协议可以加避免该问题。同时文本协议也可以减少跨平台使用所带来的诸多问题. 2.可读性强.由于 aof 是将命令写入文件中，我们可以直接查看命令内容，同时也可以修改日志文件内容. 3.开启 aof 后，所有的文件文件都包含追加操作，直接采用文本协议，减少二次开销(这一点，个人不是很理解.因为我们的 aof 是保存的是命令，当我们再次去加载的时候，会去执行一次里面的命令，当文件大的时候应该是比较耗时的吧。如果没有做好文件重写策略，大量重复无效的命令执行，对于二进制加密的 rdb 格式，不需要再去转换，这一点确实可以减少二次开销).</p>
<pre><code>文件写入</code></pre><p>文件写入是将 aof_buf 缓冲区的命令写入到文件中.文件写入的策略有如下三种方式</p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">配置说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">always</td>
<td align="center">命令写入到 aof_buf 缓冲区中之后立即调用系统的<font color="red">fsync 操作</font>同步到 aof 文件中，fsync 完成后线程返回.</td>
</tr>
<tr>
<td align="center">everysec</td>
<td align="center">命令写入到 aof_buf 缓冲区后<font color="red">每隔一秒</font>调用系统的<font color="red">write 操作</font>，write 完成后线程返回.</td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">命令写入 aof_bug 缓冲区后调用系统 write 操作，不对 aof 文件做 fsync 同步，同步硬盘操作由<font color="red">系统操作</font>完成，时间一般最长为 30s.</td>
</tr>
</tbody></table>
<p>系统调用 write 和 fsync 说明：<br>·write 操作会触发延迟写（ delayed write） 机制。 Linux 在内核提供页缓冲区用来提高硬盘 IO 性能。 write 操作在写入系统缓冲区后直接返回。 同步硬盘操作依赖于系统调度机制， 例如： 缓冲区页空间写满或达到特定时间周期。 同步文件之前， 如果此时系统故障宕机， 缓冲区内数据将丢失.<br>·fsync 针对单个文件操作（ 比如 AOF 文件） ， 做强制硬盘同步， fsync 将阻塞直到写入硬盘完成后返回， 保证了数据持久化.<br>文件写入策略分析<br>配置为 always 时， 每次写入都要同步 AOF 文件， 在一般的 SATA 硬盘上， Redis 只能支持大约几百 TPS 写入， 显然跟 Redis 高性能特性背道而驰，<br>不建议配置.<br>配置为 no。由于操作系统每次同步 AOF 文件的周期不可控， 而且会加大每次同步硬盘的数据量， 虽然提升了性能， 但数据安全性无法保证.<br>配置为 everysec。是建议的同步策略， 也是默认配置， 做到兼顾性能和数据安全性。 理论上只有在系统突然宕机的情况下丢失 1 秒的数据.</p>
<pre><code>文件重载</code></pre><p>1.为什么要文件做文件重载操作?<br>由于 aof 采用的是日志追加，我们 redis 命令不断的写入，aof 文件的体积也也会不断的增加.因此 redis 引入了 aof 重写机制达到减小 aof 文件体积.<font color="blue">aof 文件重写是把 redis 进程内的数据转换为写命令同步到新的 aof 文件的过程(这一点其实不是特别明白，文件重写不是针对 aof 文件文件做操作的吗？为什么这里是将 redis 进程内的数据转换为命令写入文件，这里的进程内的数据不是太明白，还有待深入研究.个人理解的就是将旧的 aof 文件内容根据重写策略，进行优化生成新的 aof 文件。).</font> 2.文件重载有什么好处?<br>文件重载主要优化的地方有如下三点。使用文件重载既可以减少文件的体积，同时去掉了一些无效的操作，可以加快文件重载效率.<br>a.将一些在进程内无效的数据不在写入新的文件.如过期的键.<br>b.去掉一些无效的命令.如 del key1.<br>c.简化操作.如 lpush list a,lpush list b.直接可以简化为 lpush list a b. 3.文件重载由那些方式?<br>文件重载有自动触发机制和手动触发机制.<br>手动触发机制:直接使用 bgrewriteaof 命令即可.该命令在 fork 子进程的时候会发生阻塞.<br>自动触发机制:<br>auto-aof-rewrite-min-size:aof 重写时文件最小的体积，默认的是 64M.<br>auto-aof-rewrite-percentage:代表当前 AOF 文件空间（ aof_current_size） 和上一次重写后 AOF 文件空间（ aof_base_size） 的比值.</p>
<figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自动触发时机=aof_current_size&gt;auto-aof-rewrite-minsize&amp;&amp;（ aof_current_size-aof_base_size） /aof_base_size&gt;=auto-aof-rewritepercentage</span><br></pre></td></tr></tbody></table></figure>

<p>其中 aof_current_size 和 aof_base_size 可以在 info Persistence 统计信息中查看. 4.文件重载实现的原理是怎样的?<br><img src="http://qiniucloud.qqdeveloper.com/mweb/16.png" srcset="undefined" alt="16"> 1.执行重写命令，判断是否存在子进程。<br>如果已经有子进程在进行 aof 重写，则会提示如下信息.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERR Background append only file rewriting already in progress</span><br></pre></td></tr></tbody></table></figure>

<p>如果已经存在子进程在进行 bgsave 操作，重写命令会延迟到 bgsave 命令完成之后进行，会返回如下信息.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Background append only file rewriting scheduled</span><br></pre></td></tr></tbody></table></figure>

<p>2.父进程会 fork 一个子进程，在 fork 子进程的过程中会造成阻塞.<br>3.fork 子进程结束阻塞解除，进行其他新的命令操作.新的命令依旧根据文件写入策略同步数据,保证 aof 机制正确进行(图中 3.1). 4.子进程在进行写的过程中，由于 fork 操作运用的是写时复制技术，子进程只能共享 fork 操作时内存保留的数据，新的数据是无法操作的.父进程在这过程中仍然在响应其他的命令，于是 Redis 会使用 aof 重写缓存区来保存这部分新的数据(图中 3.2). 5.子进程进行根据重写规则将数据写入到新的 aof 文件中，并且每次写入有大小限制,通过 aof-rewrite-incremental-fsync 配置项来控制，默认是 32M,这样可以见减少单次刷盘(I/O 写)造成硬盘阻塞. 6.子进程在完成重写之后，会向父进程发送信息，父进程更新统计信息.可参看 info persistence 下的 aof_*相关统计。 7.父进程会把新写入存在 aof 重写缓冲区的数据写入到 aof 文件中(图 5.2). 8.将新的 aof 文件替换掉旧的 aof 文件.<br><font color="blue">在第 3 和 4 中，其实不是特别理解.不理解的是为什么父进程在响应新的命令会写入旧的 aof 文件，还要 aof 重写缓存区.个人理解的是，父进程在进行新命令写入处理的策略是，按照正常的备份策略写入旧的 aof 的同时也把新的命令写入重写缓冲区，在第 5.2 中将这部分新的数据写入到新的 aof 文件中,这样保证数据的完整性.</font></p>
<pre><code>文件重载</code></pre><p>文件重载就是将文件重新加入到 redis 服务中.比如 redis 服务重启用于数据恢复.redis 的重载机制非常完善，具体流程如下.<br><img src="http://qiniucloud.qqdeveloper.com/mweb/16.png" srcset="undefined" alt="16"></p>
<pre><code>AOF文件常见的问题处理</code></pre><p>1.文件损坏<br>我们在加载损坏的文件是可能提示如下信息.</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bad file format reading the append only file: make a backup of your AOF file,then use ./redis-check-aof --fix &lt;filename&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>此时我们可以使用 redis-check-aof –fix 命令进行修复(记得对文件做个备份).修复后使用 diff-u 进行数据对比，找出部分丢失的数据. 2.文件加载不完整<br>这可能是数据在备份的时候，redis 服务异常，导致备份不完整.可以使用 redis 的 aof-load-truncated 兼容该异常</p>
<pre><code>AOF的优缺点</code></pre><p>优点:<br>多种文件写入(fsync)策略.<br>数据实时保存，数据完整性强.即使丢失某些数据，制定好策略最多也是一秒内的数据丢失.<br>可读性强，由于使用的是文本协议格式来存储的数据,可有直接查看操作的命令，同时也可以手动改写命令.<br>缺点:<br>文件体积过大，加载速度比 rbd 慢.由于 aof 记录的是 redis 操作的日志,一些无效的，可简化的操作也会被记录下来,造成 aof 文件过大.但该方式可以通过文件重写策略进行优化.</p>
<pre><code>选择AOF还是RDB进行数据的持久化</code></pre><p>1.针对不同的情况来选择，建议使用两种方式相结合. 2.针对数据安全性、完整性要求高的采用 aof 方式. 3.针对不太重要的数据可以使用 rdb 方式. 4.对于数据进行全量备份，便于数据备份的可以采用 rdb 方式.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Redis">Redis</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/%E5%8E%9F%E5%88%9B">原创</a>
                
                  <a class="hover-with-bg" href="/tags/Redis">Redis</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Redis持久化存储实现以及原理讲解&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
