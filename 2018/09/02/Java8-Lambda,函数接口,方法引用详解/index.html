<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="WisdowsBlog,如果人生有遗憾，那就是没有早点遇到你~">
  <meta name="author" content="Wisdows">
  <meta name="keywords" content="Wisdows, 饶弟, WisdowsBlog, 王者★孤傲">
  <title>Java8 Lambda,函数接口，方法引用详解 WisdowsBlog WisdowsBlog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<link rel="alternate" href="/atom.xml" title="WisdowsBlog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>WisdowsBlog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/16.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期日, 九月 2日 2018, 12:47 凌晨
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      12 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <p>很多人认为 java 冗余，啰嗦。在 Java 8 之前也许的确是这样，但是Java8 14年到现在，Java11马上就要来了，Java已经有了巨大的改变，lambda, Stream,Flow api 等等，Spring5 完全基于Java8 开发。因此现在到了必须学习Java 8新特性的时候。</p>
<p>现在就来详解Java8 最重要的特性，lambda和函数接口，走进函数式编程大门，本片文章主要详解使用，对原理不会深究。</p>
<p>Java8 之前，一般都是通过匿名类实现回调接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() { <span class="comment">//匿名类 编译时会生成class文件</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start(); <span class="comment">//匿名对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看看匿名类生成的文件</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    Hello$<span class="number">1</span>() {</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Java8 之后lambda和方法引用很简单美观实现接口。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">lambda 的实现通过 java7 新增的invokedynamic指令实现的，不必在编译的时候确定。</span></span><br><span class="line"><span class="comment">而且新增 java.lang.invoke 包（JSR 292）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Runnable run = () -&gt; System.out.println(<span class="string">"hello world!"</span>); <span class="comment">//lambda</span></span><br><span class="line">Runnable run1 = Hello::say;  <span class="comment">//方法引用 和 lambda 效果一样</span></span><br><span class="line">Runnable run2 = sayHello(<span class="string">"hello world!"</span>);  </span><br><span class="line"><span class="keyword">new</span> Thread(run).start();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line">	System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">sayHello</span><span class="params">(String content)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> () -&gt; System.out.println(content); <span class="comment">//lambda</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们先来学习一下什么是函数接口，Java最大缺点就是方法(函数)无法独立存在，除了基本类型就只有对象了，不像其他语言可以直接把方法当参数传递(如C#委托)，只能通过变通的方式如demo中的匿名内部类，因此Java8引入函数接口来表示方法类型，函数接口概念非常简单，<strong>只有一个抽象方法的接口就是函数接口。注：Java8 接口可以有任意多个静态方法和默认方法，Java9 又添加了私有方法，因此接口甚至可以完全取代抽象类。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//标识一个接口是不是函数接口，只起标识作用，有没有并不影响是不是函数接口的判定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;  <span class="comment">//抽象方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>{ <span class="comment">//默认方法，属于接口</span></span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; { accept(t); after.accept(t); };</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Runnable,Consumer 都是函数接口。现在来看看函数接口的特点。</span></span><br><span class="line"><span class="comment">1.接口只有一个抽象方法。</span></span><br><span class="line"><span class="comment">2.确定方法的入参(形参)，Consumer中泛型T.</span></span><br><span class="line"><span class="comment">3.确定方法的返回值。</span></span><br><span class="line"><span class="comment">事实上，一个函数接口完全可以确定一类方法。</span></span><br><span class="line"><span class="comment">如Consumer类型的方法，都是只有一个入参没有返回值，Runnable是不需要参数和没有返回值的一类方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>

<p>Java8  新增 java.util.function 包表示常用的函数接口，我们来看一下 这些接口具体表示的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">大致分为下面<span class="number">4</span>类  &lt;T&gt; 代表泛型对象，不能为基本类型，Java 这一点还是很蛋疼</span><br><span class="line"><span class="number">1</span>.Consumer     <span class="comment">//代表只有一个参数&lt;T&gt;没有返回值的一类方法</span></span><br><span class="line"><span class="number">2</span>.Function     <span class="comment">//代表只有一个参数&lt;T&gt;有返回值&lt;V&gt;的一类方法</span></span><br><span class="line"><span class="number">3</span>.Predicate    <span class="comment">//代表只有一个参数&lt;T&gt;有返回值&lt;boolean&gt;的一类方法</span></span><br><span class="line"><span class="number">4</span>.Supplier     <span class="comment">//代表没有一个参数，有返回值&lt;T&gt;的一类方法</span></span><br><span class="line"><span class="number">5</span>.UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; <span class="comment">//只有一个参数&lt;T&gt;有返回值&lt;T&gt;的一类方法</span></span><br><span class="line">同理其他的一看就知道是什么了</span><br><span class="line">BiConsumer <span class="comment">// Bi代表Binary两个， 参数&lt;T, U&gt; -&gt; void, 没有返回值 </span></span><br><span class="line">BiFunction <span class="comment">// &lt;T, U&gt; -&gt; R</span></span><br><span class="line">BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; <span class="comment">//&lt;T, T&gt; -&gt; T</span></span><br><span class="line">BiPredicate <span class="comment">// &lt;T, T&gt; -&gt; boolean</span></span><br><span class="line"></span><br><span class="line">因为Java泛型不能表示基本类型，所以提供了基本类型的函数接口。</span><br><span class="line">IntBinaryOperator  <span class="comment">// &lt;int, int&gt; -&gt; int</span></span><br><span class="line">IntConsumer  <span class="comment">// int -&gt; void</span></span><br><span class="line">IntFunction  <span class="comment">// int -&gt; R *注意* 接受的是int，返回的是对象 (diff to) ToIntFunction</span></span><br><span class="line">IntPredicate <span class="comment">// int -&gt; boolean</span></span><br><span class="line">IntSupplier  <span class="comment">// void -&gt; int</span></span><br><span class="line">IntUnaryOperator  <span class="comment">// int -&gt; int</span></span><br><span class="line">To 开头代表返回 </span><br><span class="line">ToDoubleBiFunction <span class="comment">// &lt;T, U&gt; -&gt; double</span></span><br><span class="line">ToDoubleFunction   <span class="comment">// T -&gt; double</span></span><br><span class="line">ToIntBiFunction    <span class="comment">// &lt;T, U&gt; -&gt; int</span></span><br><span class="line">ToIntFunction      <span class="comment">// T -&gt; int</span></span><br><span class="line">ToLongBiFunction   <span class="comment">// &lt;T, U&gt; -&gt; long</span></span><br><span class="line">ToLongFunction     <span class="comment">// T -&gt; long</span></span><br><span class="line">其他的想  ObjDoubleConsumer， ObjIntConsumer， ObjLongConsumer 之类的也可以望文生义了。这里再一次吐槽Java 基本类型的类类型的差别。所以 Stream 也有了与基本类型对应 IntStream,LongStream,DoubleStream</span><br></pre></td></tr></tbody></table></figure>

<p>介绍完函数接口后，我们再来介绍一下 lambda 表达式  和 方法引用。</p>
<p>所谓 lambda 表达式简单理解就是一个匿名方法，可以简化方法的定义。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Js C++, C# 等语法 使用 =&gt; 连接参数和返回值， Java不同，使用 -&gt;</span></span><br><span class="line">let add = (a, b) =&gt; a + b;  </span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">IntBinaryOperator intAdds = (a, b) -&gt; a + b; <span class="comment">// intAdds 是一个函数对象</span></span><br><span class="line">intAdds.applyAsInt(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//3  调用 intAdds的方法，这也是函数接口只能有一个抽象方法的原因。</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>看到什么了吗？虽然 lambda 没有 Js 那么灵活。但是 没有lambda 之前，Java 方法只能所属于具体类，不能单独存在（即所谓的方法不是一级公民），方法无法临时创建，也无法传递。而动态语言和其他支持 lambda 的静态语言，就很灵活，因为Java 与时俱进，在Java 8 中支持了此特性。</strong></p>
<p>没有lambda 之前，Java 无法创建局部方法[即在方法中定义方法]想要实现回调方法一般只能定义一个匿名类，生成其对象，然后传入参数，如文章最开始的时候 。Java8 之后 集合框架加入了大量 函数式支持。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!!!"</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//void forEach(Consumer&lt;? super T&gt; action) 接受一个Consumer对象，即 T -&gt; void</span></span><br><span class="line">list.forEach(s -&gt; System.out.println(s)); <span class="comment">//输出每一项，如果我们求每一项长度，lambda可能就没那么美观了</span></span><br><span class="line">list.forEach(s -&gt; { <span class="comment">//超过一行的 lambda 方法体用要用 {} 括起来</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) {</span><br><span class="line">        System.out.println(<span class="string">"字符串为null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     }</span><br><span class="line">     System.out.println(s.length());</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>如果每次都要写很长的 lambda，那其实没省效率，而且代码重用率极低。因此，方法引用登场。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所谓方法引用 即方法是一种类型，是函数接口的引用，fun 就是方法的引用, 右边就是实际方法对象[lambda]</span></span><br><span class="line"><span class="comment">eg: Object obj = "hello"; obj 是引用， "hello" 是实际对象</span></span><br><span class="line"><span class="comment">方法引用相当于 对现有所有方法的重复利用 */</span></span><br><span class="line">Function&lt;String, Integer&gt; fun = s -&gt; s.length(); <span class="comment">// 相当于下面</span></span><br><span class="line">Function&lt;String, Integer&gt; fun1 = String::length;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>:: 方法引用运算符，标准形式是：类名::方法名 有下面四种形式引用静态方法</strong>  </p>
<ol>
<li><p><strong>Class::staticMethodName            引用静态方法[类名::静态方法名]</strong></p>
</li>
<li><p><strong>obj::instanceMethodName           引用某个对象的实例方法[对象::实例方法名]</strong></p>
</li>
<li><p><strong>ClassName::new                           引用构造方法</strong>  </p>
</li>
<li><p><strong>Type::methodName                      引用某个类型的任意对象的实例方法</strong>    </p>
</li>
</ol>
<p><strong>下面重点介绍一下，尤其是令人困惑第四种。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面以 String 的方法为例</span></span><br><span class="line">Function&lt;Object, String&gt; fun = String::valueOf; <span class="comment">//形式1, 等价于 obj -&gt; String.valueOf(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String content)</span> </span>{ <span class="comment">// Hello 类有 sayHello实例方法 </span></span><br><span class="line">   System.out.println();</span><br><span class="line">}</span><br><span class="line">Hello hello = <span class="keyword">new</span> Hello(); </span><br><span class="line">Consumer&lt;String&gt; con = hello::sayHello; <span class="comment">//形式2 通用实例方法引用 等价于 s -&gt; hello.sayHello(s)</span></span><br><span class="line">Consumer&lt;String&gt; con1 = <span class="keyword">this</span>::sayHello; <span class="comment">//形式2 在此类(Hello)实例方法可以使用 s -&gt; this.sayHello(s)</span></span><br><span class="line"></span><br><span class="line">Supplier&lt;Hello&gt; supplier = Hello::<span class="keyword">new</span>; <span class="comment">// 形式3  () -&gt; new Hello();</span></span><br><span class="line">Hello hello1 = supplier.get(); <span class="comment">//每次调用产生新的Hello对象，所以叫供应商</span></span><br><span class="line"></span><br><span class="line">BiConsumer&lt;Hello, String&gt; biCon = Hello::sayHello; <span class="comment">//形式4， 相当于 hello::sayHello</span></span><br><span class="line">sayHello.accept(hello, <span class="string">"hello"</span>); <span class="comment">//不过运行是需要传递这个对象</span></span><br><span class="line"><span class="comment">/* *某个类型的任意对象的实例方法*, 不像形式2，此方法应经绑定了对象，</span></span><br><span class="line"><span class="comment">在引用是并不知道是哪个对象，必须传入，而且一定是第一个参数，如 hello，也可以传入Hello子类对象 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>; <span class="comment">//String length方法签名，按照之前定义的无参，有返回值 </span></span><br><span class="line"><span class="comment">//void -&gt; int 明明是 Supplier&lt;Integer&gt;/IntSupplier 为什么变成了 Function T -&gt; R</span></span><br><span class="line"><span class="comment">//这是因为 形式4 并不能知道调用方法的是哪个对象，必须传入【第一个参数】才知道</span></span><br><span class="line">Function&lt;String, Integer&gt; length = String::length;</span><br><span class="line"><span class="keyword">int</span> len = length.apply(<span class="string">"hello world"</span>); <span class="comment">//求任意String类型对象的长度</span></span><br></pre></td></tr></tbody></table></figure>

<p>介绍了lambda和函数接口，方法引用后。学会已经可以大显身手了，但是 lambda 肯定还有更高深的内容等着你，那就是</p>
<p>lambda 组合，lambda 本身还可以和本身组成更复杂的 lambda [依赖于默认方法]。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了 java.util.function 包之外的 常用的函数接口</span></span><br><span class="line">Runnable  <span class="comment">//@since 1.0  线程任务接口</span></span><br><span class="line">Callable&lt;V&gt; <span class="comment">//@since 1.5 有返回值的线程任务接口</span></span><br><span class="line">Comparable&lt;T&gt; <span class="comment">//@since 1.2  内比较器 int compareTo(T o)</span></span><br><span class="line">Comparator&lt;T&gt; <span class="comment">//@since 1.2  外比较器 常用于排序</span></span><br><span class="line">Thread.UncaughtExceptionHandler <span class="comment">//@since 1.5 线程异常处理接口</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//lambda 组合，我们以 Function 为例子，看一下 Function 源码</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>{</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>{</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>{</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 抽象方法apply，两个默认方法compose，andThen，静态方法identity</span></span><br><span class="line">Function&lt;Integer, Integer&gt; square = e -&gt; e * e;  <span class="comment">// e的平方</span></span><br><span class="line">Function&lt;Integer, Integer&gt; dou = e -&gt; <span class="number">2</span> * e;    <span class="comment">// e的双倍</span></span><br><span class="line"><span class="keyword">int</span> a = square.compose(dou).apply(<span class="number">3</span>);  <span class="comment">//36</span></span><br><span class="line"><span class="keyword">int</span> b = square.andThen(dou).apply(<span class="number">3</span>);  <span class="comment">//18</span></span><br><span class="line"><span class="keyword">int</span> c = dou.compose(square).apply(<span class="number">3</span>);  <span class="comment">//18</span></span><br><span class="line"><span class="keyword">int</span> d = dou.andThen(square).apply(<span class="number">3</span>);  <span class="comment">//36</span></span><br><span class="line"><span class="comment">//compose 在本身之前先算 andThen 在本身之后再算</span></span><br><span class="line">(V v) -&gt; apply(before.apply(v)); <span class="comment">//先计算 before.apply(v)</span></span><br><span class="line">(T t) -&gt; after.apply(apply(t));  <span class="comment">//apply(t)</span></span><br><span class="line"><span class="comment">//如果能理解源码，当然最好，初学者可以记住，compose从最后往前算，andThen重前往后算</span></span><br><span class="line"><span class="comment">// ((4 * 3)^2 * 2 * 3)^2 * 2 = 1492992</span></span><br><span class="line"><span class="keyword">int</span> e = dou.andThen(tripe).compose(square).andThen(square).compose(tripe).andThen(dou).apply(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda 组合 常用的场景之一就是排序 Comparator </span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    ****多个 <span class="keyword">default</span> method;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* Comparator 竟然有两个抽象方法 compare,equals 不是说函数接口只能有一个抽象方法吗？equals 其实是 Object 类的方法，**所有引用类型都继承Object，当然包括接口**,所以函数接口中可以重新声明Object类的方法。*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Compare</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Comparable</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(T a, T b)</span></span>; <span class="comment">//这个就不是函数接口，无法通过编译</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"he"</span>, <span class="string">"b hello"</span>, <span class="string">"a hello world!"</span>, <span class="string">"world"</span>, <span class="string">"hello"</span>, <span class="string">"ha"</span>)); </span><br><span class="line"><span class="comment">//多条件组合排序 先根据长度排序再根据自然排序 [ha, he, hello, world, b hello, a hello world!]</span></span><br><span class="line">list.sort(Comparator.comparing(String::length).thenComparing(Comparator.naturalOrder()));</span><br></pre></td></tr></tbody></table></figure>

<p>Java8 支持 lambda之后, 9,10,11 版本都进行了扩展，虽然 lambda 效率低于匿名类，但是获得更加简洁的写法，更强的语义。Java Collection, Map, Arrays 添加了大量lambda api，大家在写代码的时候学以致用，下面一篇文章将详解Java8新增的 Optional 和 Stream。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先看看 Stream 的强大作用</span></span><br><span class="line"><span class="comment">// List 去除 null, 去重后求和</span></span><br><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="keyword">null</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> sum = nums.stream().filter(Objects::nonNull).distinct().mapToInt(Integer::intValue).sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 分组  根据城市分组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{ <span class="comment">// 员工</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    ****</span><br><span class="line">}</span><br><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">employees.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="string">"杭州"</span>, <span class="number">100</span>));</span><br><span class="line">employees.add(<span class="keyword">new</span> Employee(<span class="string">"小兰"</span>, <span class="string">"嘉兴"</span>, <span class="number">85</span>));</span><br><span class="line">employees.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="string">"杭州"</span>, <span class="number">80</span>));</span><br><span class="line">employees.add(<span class="keyword">new</span> Employee(<span class="string">"王二"</span>, <span class="string">"兰州"</span>, <span class="number">95</span>));</span><br><span class="line"><span class="comment">// Stream 一行代码搞定， Stream 就是对集合的增强，我们下篇见</span></span><br><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; result =</span><br><span class="line">                employees.stream().collect(Collectors.groupingBy(Employee::getCity));</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Java%20SE">Java SE</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/java">java</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Java8 Lambda,函数接口，方法引用详解&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
