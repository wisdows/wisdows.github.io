<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="WisdowsBlog,如果人生有遗憾，那就是没有早点遇到你~">
  <meta name="author" content="Wisdows">
  <meta name="keywords" content="Wisdows, 饶弟, WisdowsBlog, 王者★孤傲">
  <title>JVM类加载机制 WisdowsBlog WisdowsBlog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<link rel="alternate" href="/atom.xml" title="WisdowsBlog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>WisdowsBlog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/16.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期六, 十一月 17日 2018, 5:02 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    7.1k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      25 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <p>虚拟机把类的描述数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在 Java 语言里面，类型的加载、链接、初始化过程都是在程序运行期间完成的。</p>
<a id="more"></a>

<h3 id="1-类加载的时机"><a href="#1-类加载的时机" class="headerlink" title="1. 类加载的时机"></a>1. 类加载的时机</h3><pre><code>类从被加载到内存中开始，到被卸载出内存结束。它的声明周期共经历了七个阶段：</code></pre><p><img src="https://blog-1253360328.cos.ap-guangzhou.myqcloud.com/image/class_load_process.jpg" srcset="undefined" alt="类加载的过程"><br>          上图中的加载、验证、准备、初始化和卸载这五个过程是确定的，类加载的过程必须按照这个顺序开始（不是进行和完成）。但是，解析阶段就不一定，在某些时候可以在初始化后再开始，这是为了支持 Java 的运行时绑定。Java 虚拟机规范中并没有强制规定什么时候加载类，所以可以由虚拟机的具体实现来确定。但是对于初始化阶段，虚拟机规范中指出，有且只有以下5中情况必须立即对类进行”初始化”（在初始化之前自然已经开始了加载、验证、准备等阶段）。<br>       1)、遇到new（使用new 关键字实例化对象）、getstatic（读取类的静态字段（被final修饰放入常量池的静态字段除外））、putstatic（设置类的静态字段（被final修饰放入常量池的静态字段除外））或者invokestatic（调用一个类的静态方法）这四条字节码指令时，如果此时类还没有进行初始化，就需要先触发类开始初始化。<br>       2)、使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果此时类没有进行初始化，则需要触发类开始初始化。<br>       3)、在初始化一个类时，如果发现其父类还没有初始化，则需要先触发父类的初始化。<br>       4)、当虚拟机启动时，用户需要执行一个需要执行的主类，虚拟机会先初始化这个主类，<br>       5)、当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。<br>       以上五种场景中的行为称为对一个类的主动引用。除此之外，所有引用类的方法都不会触发初始化，称为被动引用。<br>       对于静态字段，通过以下三个示例进行说明。<br>       代码示例1如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.saz.classinit</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> * 但是加载和验证取决于具体的实现，HotSpot 会加载子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行输出结果：</span></span><br><span class="line"><span class="comment">// SuperClass init!</span></span><br></pre></td></tr></tbody></table></figure>
<pre><code>通过上面的示例，可以看出：只有直接定义这个字段的类才会被初始化，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化
而不会触发子列的初始化。至于是否触发子类的加载和验证，虚拟机规范中没有明确规定，取决于虚拟机的具体实现。对于 Sun HotSpot
虚拟机来说，可通过 -XX:TraceClassLoading 参数看到此操作会导致子类的加载。

代码示例2如下：</code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SuperClass[] sc = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行没有输出结果</span></span><br></pre></td></tr></tbody></table></figure>
<pre><code>在执行示例2的代码后，发现没有输出，这说明并没有触发 SuperClass 类的初始化。但是在这段代码里触发另外一个类
Lcn.saz.classinit.SuperClass 的初始化，这个类时有虚拟机自动生成的，直接继承 java.lang.Object 类，创建动作有字节码
指令 newarray 触发。这个类代表了一个元素类型为 cn.saz.classinit.SuperClass 的一维数组，数组中拥有的属性和方法都实现
在这个类里面。</code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">package</span> cn.saz.classinit;</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span> </span>{</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO = <span class="string">"HELLO WORLD!"</span>;</span><br><span class="line">   	<span class="keyword">static</span> {</span><br><span class="line">   		System.out.println(<span class="string">"ConstantClass init!"</span>);</span><br><span class="line">   	}</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接</span></span><br><span class="line"><span class="comment">    * 引用到定义常量的类，因此不会触发定义常量的类的初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">   		System.out.println(ConstantClass.HELLO);</span><br><span class="line">   	}</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<pre><code>在上述代码中，看到只输出了 HELLO WORLD!，由此可以看出，ConstantClass并没有初始化。出现这种情况主要是因为 编译阶段的常量
传播优化：在编译阶段，就已经将此常量的值 "HELLO WORLD!" 存储到 Test 类的常量池中，以后 Test 类对常量的引用实际上都被转
化为对自身常量池的引用。

至于接口的加载过程与类的加载有点不同，主要是上面五点中第三点，接口在初始化时并不要求父接口全部都完成了初始化，只有在真正使
用时才会初始化。</code></pre><h3 id="2-类加载的过程"><a href="#2-类加载的过程" class="headerlink" title="2. 类加载的过程"></a>2. 类加载的过程</h3><pre><code>类加载的过程主要是指加载、验证、准备、解析和初始化五个阶段</code></pre><h4 id="2-1-加载阶段"><a href="#2-1-加载阶段" class="headerlink" title="2.1 加载阶段"></a>2.1 加载阶段</h4><pre><code> 在加载阶段，虚拟机需要完成以下3件事情：
  1). 通过类的全限定名获取定义此类的二进制字节流
  2). 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构
  3). 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
在第一件事情中，虚拟机并没有指明字节流应该从哪里获取以及如何获取，所以这个可以从很多地方获取。eg:
  1). 从 ZIP 包读取。从JAR，EAR，WAR 中读取类就依赖于此
  2). 从网络中读取。例如：Applet
  3). 运行时及计算生成。例如：动态代理
  4). 由其他文件生成。例如：由 JSP 文件生成对应的类
  5). 从数据库中读取。比较少见，常用于中间件服务器
对于一个非数组类，类的加载阶段相比其他阶段对开发人员来说是可控性最强的。因为开发人员可以使用自定义的类加载完成类的加载；
甚至可以通过自定义的类加载器去控制字节流的方式（重写类加载的loadClass()方法）。
对于数组类，情况就不同了，数组类本身不通过类加载器创建，它是由Java 虚拟机直接创建（通过字节码指令 newarray 创建）。
但是数组类与类加载器还有有紧密关系的，因为数组的元素的元素类型最终还是需要靠类加载器去创建。一个数组类的创建过程遵循以
下过程：
  1). 如果数组的组件类型（去掉一个维度的类型）是引用类型，那就递归采用标准的加载过程去加载这个组件，数组类将在加载该类
  组件类型的类加载器的类名称空间上被标识。
  2). 如果数组的组件类型不是引用类型（eg:int[] 数组）,Java 虚拟机将会把数组类标记为引导类加载器关联。
  3). 数组类的可见性与它的组件类型的可见性一致。如果组件类型不是引用类型，那么数组类的可见性将默认为 public.

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中数据存储格式由虚拟机实现自定义，
虚拟机规范中没有规定此区域的数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（Class 对象比较特殊，虚拟机
规范中没有明确在Java 堆中分配内存，但是对于HotSpot 虚拟机而言，它虽然是对象，凡是存放在方法区里面）。这个对象将作为
程序访问方法区中的这些类型数据的外部接口。
加载阶段与连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但是这个加载加载阶段之中进行的动作，
然属于连接阶段，这两个阶段的开始时间还是保持着固定的先后顺序。</code></pre><h4 id="2-2-验证阶段"><a href="#2-2-验证阶段" class="headerlink" title="2.2 验证阶段"></a>2.2 验证阶段</h4><pre><code>    验证是连接阶段的第一步，验证的目的为了保证字节流中包含的信息时是符合当前虚拟机的要求，不会危害虚拟机自身的安全。
  我们知道，Java 语言本身是相对安全的，由 Java 代码编译而来的字节码也是相对比较安全的。但是，虚拟机加载的 Class 文件
  字节流并不一定是由 Java 代码编译而来，可能来自网络等其他任何途径。所以，仅认定加载的是 Class 文件字节流是无法保证虚
  拟机的安全。因此，虚拟机需要很严谨的验证载入的 Class 文件字节流（是否严谨决定了虚拟机能否承受恶意代码的攻击）。
  验证阶段的工作在虚拟机的类加载子系统中占了相当大的一部分。其大致上会执行以下四个阶段的工作：
    1). 文件格式验证
        这个阶段的验证是基于二进制字节流进行 ，需要验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚
        拟机处理。
        这个阶段的主要目的是保证输入的字节流能够正确的被解析并存储在方法区内，格式上符合描述一个 Java 类型信息的要求。
        通过这个验证后，字节流就会存入内存的方法区。
        这个阶段的验证主要包含如下：
            (1). 是否以魔数 0xCAFEBABY 开头
            (2). 主、次版本号是否在当前虚拟机处理范围之内
            (3). 常量池的常量中是否有不被指出的常量类型（检查常量 tag 标志）。
            (4). 指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量。
            (5). Class 文件中各个部分及文件本身是否具有被删除的或者附加的其他信息。
            ......
    2). 元数据验证
        这个阶段是对字节码描述的信息进行语义分析校验，以保证字节码描述的信息符合 Java 语言规范的要求。主要校验的关键
        点有以下几点：
        (1). 这个类书否有父类（除了 java.lang.Object 之外，所有的类都应该有父类）
        (2). 这个类的父类是否继承了不允许被继承的类
        (3). 如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法。
        (4). 类中的字段、方法是否与父类产生矛盾（eg:覆盖了父类的final字段，或者不符合规则的方法重载）。
    3). 字节码验证
        这个验证是最复杂的一个验证，主要是通过数据流和控制流分析，确定程序语义是合法的、合乎逻辑的。在完成对元数据中的
        数据类型的校验后，这个阶段将对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的事件。
        eg：
            (1). 保证任意时刻操作数栈的数据类型与指令序列都能配合工作。eg:在操作栈放置了一个int类型的数据，但使用时
            却按照 long 类型来载入本地变量表。
            (2). 保证跳转指令不会跳转到方法体以外的字节码指令上。
            (3)、保证方法体中的类型转换是有效的。
        即时一个方法通过了字节码验证，也不能说这个方法一定是安全的。由于数据流验证的高复杂性，虚拟机设计团队为了避免消
        耗过多的时间在字节码验证阶段，所以在 JDK 1.6 之后的 javac 编译器和 Java 虚拟机中进行了一项优化，给方法体的
         Code 的属性表增加了一项名为 "StackMapTable" 的属性，这项属性描述了方法体中所有的基本快(按照控制流拆分的代
           码块)开始时在本地变量表和操作站应有的状态，在字节码验证期间，就不需要根据程序去推导这些状态的合法性，只需要
           检查 StackMapTable属性中的记录是否合法。
        在 JDK 1.6 的 HotSpot 虚拟机中提供了 -XX:UsrSplitVerifier 选项来控制这项优化，或者使用参数
        -XX:+FailOverToOldVerifier 来要求类型校验失败的是否退回到旧的类型推导方式进行校验。但是在 JDK 1.7 后，
        对于主版本号大于 50 的 Class 文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许退回到类型推导的校
        验方式。
    4). 符号引用验证
        符号引用验证是在将符号引用转化为直接引用的时候发生，这个转化动作将在连接的第三阶段(解析阶段)中发生。符号引用验
        证的目的是确保解析动作能正常执行。 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性
        校验，通常需要校验下列内容：
        (1). 符号引用中通过字符串描述的全限定名是否能找到对应的类。
        (2). 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
        (3). 符号引用中的类、字段、方法的访问性是否可以被当前类访问。
        ......
对于虚拟机的类加载机制来说，验证阶段是一个非常重要，但不是一定必要的阶段。如果所运行的全部代码都已经被反复使用和验证过，
那么在实施阶段就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施。</code></pre><h4 id="2-3-准备阶段"><a href="#2-3-准备阶段" class="headerlink" title="2.3 准备阶段"></a>2.3 准备阶段</h4><pre><code>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存
分配的仅包括类变量(被 static 修饰的变量)，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。
另外，这里的设置类变量初始值的初始值**通常情况**下是数据类型的零值，假设一个类变量的定义为：</code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></tbody></table></figure>
<pre><code>那变量 value 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为123的
putstatic 指令是程序被编译后，存放在类构造器 &lt;clinit&gt;() 方法中，所以把 value 赋值为123的动作将在初始化阶段才会执行。
在另外的特殊情况下：如果类字段的字段属性表中存在 ConstantValue 属性，那么在准备阶段变量 value 就会被初始化的
ConstantValue 属性所指定的值。eg:</code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h4><pre><code>解析阶段是虚拟机将常量池内的符号引用转换为直接引用的过程。
   符号引用：
     符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够定位到目标即可。符号引用与虚拟机
     的内存布局无关，引用的目标并不一定需要已经加载到内存中。由于各种虚拟机的内存布局实现不同，但是他们能接受的符号引
     用必须是一致的，所以符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class文件格式中。
   直接引用：
     直接引用可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，
     同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中
     存在。
   在虚拟机规范中，没有规定解析阶段发生的具体时间，只要求在执行 newarray、checkcast、getfield、getstatic、
 instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、
 ldc_w、multianewarray、new、putfield 和 putstatic 这些用于操作符号引用的字节码指令之前。
 对于同一个符号引用可以进行多次解析请求，并且这也是很常见的事情，除了 invokedynamic 指令以外，虚拟机可以对第一次解析
 的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态），这样可以避免重复进行解析动作。但是，无论是否
 真正执行了多次解析，虚拟机都需要保证在同一个实体中，如果一个符号引用之前已经成功解析，那么后续的解析就应一直成功；如果
 失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。对于 invokedynamic 指令，上述规则是不成立的。如果一个符
 号引用已经由 invokedynamic 指令触发过解析，但这并不意味着这个解析结果对于其他 invokedynamic 指令同样生效。因为
 invokedynamic 这个指令本来就是用于动态语言支持。
 解析动作主要是针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号阴影进行，分别对应于常量
 池的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、
 CONSTANTS_InterfaceMethodref_info、CONSTANT_MethodType_info、
 CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7 中常量类型。
 1). 类或接口的解析
     假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用,那虚拟机完成整个解析的过程
     需要以下3个步骤:   
       (1).  如果C不是一个数组类型,那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中,由于元数
       据验证、字节码验证的需要,又可能触发其他器去加载这个类C。在加载过程中,由于元数据验证、字节码验证的需要,又可能触发
       其他常,解析过程就宣告失败.
       (2). 如果C是一个数组类型,并且数组的元素类型为对象,也就是N的描述符会是类似“[ Ljava/lang/ Integer”的形式,那将
       会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式,需要加载的元素类型就是“ java.lang.Integer”,
       接着由虚拟机生成一个代表此数组维度和元素的数组对象。
       (3). 如果上面的步骤没有出现任何异常,那么C在虚拟机中实际上已经成为一个有效的类或接口了,但在解析完成之前还要进行符
       号引用验证,确认D是否具备对C的访问权限。如果发现不具备访问权限,将抛出 java.lang.Illegalaccess Error异常。
 2). 字段解析
     要解析字段符号引用（字段所属的类假设是C），首先将会对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号
     引用进行解析，也就是字段所属类或者接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段
     符号引用解析的失败。如果解析成功完成，虚拟机规范中要求按照如下步骤对 C 进行后续的字段搜索，搜索过程如下：
       (1). 如果C本身就包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。
       (2). 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和
       字段描述符斗鱼目标相匹配的字段，则返回这个字段的直接引用，查找结束。
       (3). 否则，如果C不是 java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称
       和字段描述符都与目标相匹配的子弹，则返回这个子弹的直接引用，查找结束。
       (4). 否则，查找失败，抛出 java.lang.NoSuchFieldError异常。
     如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将派出
     java.lang.IllegalAccessError异常。如果一个字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，
     那编译器将可能拒绝编译。
 3). 类方法解析
     类方法解析的第一步与字段解析一样，需要先解析出类方法表的class_index 项中索引的方法所属的类或接口的符号引用，
     如果解析成功，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。依然用C表示这个类。
     (1). 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_info 中索引的C是个接口，
     则会抛出 java.lang.IncompatibleClassChangeError 异常。
     (2). 如果通过了第一步，在类C中查找是否有简单名称和描述符斗鱼目标相匹配的方法，如果有则返回这个方法的引用，查找结束。
     (3). 否则，在类C的父类中递归查找是否简单名称和描述符都与目标相匹配的方法。如果有则返回这个方法的直接引用，查找结束。
     (4). 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有匹配的方
     法，说明类C是一个抽象类，这是查找结束，抛出 java.lang.AbstractMethodError 异常。
     (5). 否则，宣布方法查找失败，抛出 java.lang.NoSuchMethodError 异常。
     最后，如果查找成功，将会对这个方法进行权限验证，如果不具备此方法的访问权限，将抛出 java.lang.IllegalAccessError
      异常。
 4) 接口方法解析
    接口方法解析的第一步与字段解析一样，需要先解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用，
    如果解析成功，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。依然用C表示这个接口。
      (1). 如果接口方法表中发现 class_index 中的索引的方法所属的类是个类而不是接口，那就直接抛出
      java.lang.IncompatibleClassChangeError 异常。
      (2). 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接阴影，查找结束。
      (3). 否则，在接口 C的父接口中递归查找，直到 java.lang.Object 类（查找范围会包括 Object 类）为止，看是否有简单
      名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      (4). 否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError 失败
      (5). 由于接口中的所有方法默认都是 public 的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出
      java.lang.IllegalAccessError 异常。</code></pre><h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h4><pre><code>类加载阶段是类加载过程中的最后一个阶段，在前面几个类加载的阶段中，除了可以自定义类加载之外，剩下的操作全部都有虚拟机完成。
在初始化阶段，才真正意义上执行类中定义的字节码。
在准备阶段，某些变量已经经过虚拟机赋值了一个初始值。但是在初始阶段，虚拟机会根据Java代码的计划去初始化类变量和其他资源。
其实，初始化的过程就是执行类构造器 &lt;clinit&gt;() 方法的过程。
 &lt;clinit&gt;() 方法介绍：
     1). &lt;clinit&gt;() 方法是有编译器收集类中所有类变量的赋值动作和所有的静态语句块(static{})的语句合并产生的。
       收集的顺序就是代码在源文件出现的顺序。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，
       只能赋值，不能访问。
       eg：</code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        i = <span class="number">10</span>;  <span class="comment">//可以正常编译</span></span><br><span class="line">        System.out.println(i); <span class="comment">// 编译错误，非法的向前引用</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<pre><code>2). &lt;clinit&gt;() 与类的构造函数（&lt;init&gt;()方法）是不同的，在执行 &lt;clinit&gt;() 方法之前，不需要显示调用父类的
构造器,因为虚拟机会保证在执行子类的 &lt;clinit&gt;() 方法之前，父类的 &lt;clinit&gt;() 方法会被执行。所以在Java代码中，
最先执行的&lt;clinit&gt;() 方法的类时 java.lang.Object。
3). 由于父类的 &lt;clinit&gt;() 会优先于子类的 &lt;clinit&gt;() 方法执行，所以父类的静态语句块和类变量的赋值操作会先
于子类的执行。
eg:</code></pre><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> {</span><br><span class="line">			A = <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(Sub.B);  <span class="comment">// 输出2，因为父类的静态语句块优先于子类的执行</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<pre><code>4). 接口中不能使用静态语句块，但是可以有类变量的赋值动作，所以接口也会生成 &lt;clinit&gt;() 方法，但是，接口的 &lt;clinit&gt;()
方法执行之前不需要先执行父类的 &lt;clinit&gt;() 方法。只有在使用父接口的变量时，才会初始化父类。另外，接口的实现类在初始化时
也不会执行接口的 &lt;clinit&gt;() 方法。
5). &lt;clinit&gt;() 方法在多线程环境下的执行是安全的，虚拟机会正确的加锁、同步。所以不管有多少个线程去执行 &lt;clinit&gt;()
方法，最终都只有一个线程能够执行。其他的线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 结束。</code></pre><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/JVM">JVM</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/jvm">jvm</a>
                
                  <a class="hover-with-bg" href="/tags/class%20loader">class loader</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JVM类加载机制&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
